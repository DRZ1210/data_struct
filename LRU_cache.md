## C++模拟 LRU 页面置换算法

首先对于页面置换中的最近最久未使用替换算法，需要使用的数据结构有：

1. 告知内存最多能够容纳页面的数量（此处假设每一个页面就对应一个结点）

2. `unordered_map<key, Node *> mmap`

   `hashTable` 中第一项存储的是双向链表中结点的key值，第二项存储的是结点在内存中的地址

   此处`hashTable`最大的作用就是判断当前页面是否在内存中，若存在则返回其在内存中的地址

3. 双向队列

   最近最久未使用，如何实现这样的算法呢？

   我们在双向队列中添加虚拟头结点head和尾结点tail（真的会方便很多，减少空指针的判断），定义越靠近头结点的结点越是最近使用的，越靠近tail的结点越最久未使用。

   当CPU需要访问某结点时，首先通过`hashTable`判断所需页面是否在内存中，若在直接访问，同时更新该结点的位置，将其移动到头结点的位置。若不在则访问失败。

   当向内存中存入该结点时，首先判断该页面是否已有该结点，若已存在，则找到该结点在内存中的位置，更新结点的内容，若不在内存中，需要将该结点存入内存中，此时又需要判断该内存是否已满，若没满，则创建结点之后，将结点放在队列的头部，若内存已满，则根据`LRU`替换算法的规则，需要将最久没有使用的结点调离内，也就是双向队列中最后的那个结点从队列中删除。

4. 最后再次强调，在处理链表相关操作时，使用虚拟头结点和尾结点将会方便很多，较少空指针的判断，从而减少段错误的发生。



